<!DOCTYPE html>
<html lang="uz">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Ferkaveka ‚Äî 2D Shooter (Dizayn + Yuklanmoqda)</title>
<style>
  :root{
    --bg1:#071526; --bg2:#06283b; --accent:#39a9db; --accent-2:#7fe0ff;
    --panel: rgba(10,30,45,0.6);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter, "Segoe UI", Roboto, Arial; background:linear-gradient(180deg,var(--bg1),#041426); color:#e6f7ff; overflow:hidden}
  #app{position:relative;width:100vw;height:100vh;display:flex;align-items:center;justify-content:center;padding:18px}
  canvas{border-radius:14px; box-shadow: 0 18px 60px rgba(2,6,12,0.75); background: linear-gradient(180deg,#062033,#041527); display:block}
  /* Top header with logo + title */
  #titleBar{position:absolute;top:18px;left:18px;right:18px;display:flex;align-items:center;gap:14px;z-index:220;pointer-events:none}
  #logoWrap{display:flex;align-items:center;gap:12px;background:linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:8px 12px;border-radius:12px;border:1px solid rgba(63,155,210,0.08)}
  .logoSVG{width:56px;height:56px;flex:0 0 56px}
  #titleText{font-weight:800;font-size:22px;letter-spacing:2px;color:var(--accent-2);text-shadow:0 6px 22px rgba(15,120,180,0.08);pointer-events:auto}
  #subtitle{font-size:12px;color:rgba(255,255,255,0.65);margin-left:6px}
  /* UI left */
  #ui{position:absolute;left:18px;top:94px;z-index:210;display:flex;flex-direction:column;gap:12px}
  .statPanel{background:var(--panel);padding:10px 14px;border-radius:12px;border:1px solid rgba(63,155,210,0.06);min-width:180px}
  .statRow{display:flex;justify-content:space-between;align-items:center;font-weight:700}
  .hpBar{height:14px;background:rgba(255,255,255,0.06);border-radius:8px;overflow:hidden;margin-top:8px}
  .hpFill{height:100%;background:linear-gradient(90deg,#ff6b6b,#ffcc6b);width:100%;transition:width 260ms linear}
  /* Top-right small buttons */
  #topRight{position:absolute;top:18px;right:18px;display:flex;gap:8px;z-index:210}
  .iconBtn{background:var(--panel);border-radius:10px;padding:8px 10px;border:1px solid rgba(63,155,210,0.06);cursor:pointer;color:var(--accent-2);font-weight:800}
  /* Overlays */
  .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:300}
  .hidden{display:none}
  /* Loading overlay */
  #loadingOverlay{background:linear-gradient(180deg,rgba(0,0,0,0.65),rgba(3,8,12,0.85));backdrop-filter: blur(6px);flex-direction:column;gap:16px}
  .loadBox{background:linear-gradient(180deg,#082a3d,#071b2a);padding:22px;border-radius:14px;border:1px solid rgba(63,155,210,0.08);text-align:center;box-shadow:0 20px 60px rgba(2,6,12,0.7)}
  .pulse{font-weight:800;color:var(--accent-2);font-size:20px;animation:pulse 1.2s infinite}
  @keyframes pulse {0%{opacity:0.35;transform:scale(0.98)}50%{opacity:1;transform:scale(1.03)}100%{opacity:0.35;transform:scale(0.98)}}
  /* Start panel */
  .panel{background:linear-gradient(180deg,#082a3d,#072630);padding:18px;border-radius:12px;border:1px solid rgba(63,155,210,0.08);box-shadow:0 14px 40px rgba(2,8,12,0.65);text-align:center}
  .panel h1{margin:0;color:var(--accent-2);letter-spacing:1px}
  .panel p{color:rgba(255,255,255,0.8);margin-top:6px}
  .btn{margin-top:12px;padding:10px 16px;border-radius:10px;background:linear-gradient(90deg,var(--accent),#2e8fb8);border:none;color:#04212c;font-weight:800;cursor:pointer}
  .btn:hover{filter:brightness(.95)}
  /* Touch buttons */
  #touchLeft,#touchRight{position:absolute;bottom:18px;z-index:210;display:flex;gap:10px}
  #touchLeft{left:18px} #touchRight{right:18px}
  .touchBtn{width:68px;height:68px;border-radius:12px;background:rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;border:1px solid rgba(63,155,210,0.06);font-weight:800;color:var(--accent-2);touch-action:none}
  .touchBtn:active{background:rgba(63,155,210,0.12)}
  /* Floating score text */
  .floatText{position:absolute;pointer-events:none;font-weight:900;color:#fff;text-shadow:0 6px 18px rgba(0,0,0,0.7);z-index:500}
  /* small responsive */
  @media (max-width:720px){ #titleText{font-size:18px} .logoSVG{width:46px;height:46px} .statPanel{min-width:150px} }
</style>
</head>
<body>
  <div id="app">
    <!-- Title & Logo -->
    <div id="titleBar">
      <div id="logoWrap">
        <!-- Inline SVG placeholder logo -->
        <svg class="logoSVG" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" aria-hidden>
          <defs>
            <linearGradient id="g1" x1="0" x2="1"><stop offset="0" stop-color="#39a9db"/><stop offset="1" stop-color="#7fe0ff"/></linearGradient>
          </defs>
          <rect x="6" y="6" width="88" height="88" rx="16" fill="url(#g1)" />
          <g transform="translate(16,16)" fill="#04212c" font-weight="900" font-size="44">
            <text x="8" y="53">F</text>
          </g>
        </svg>

        <div style="display:flex;flex-direction:column;pointer-events:none">
          <div id="titleText">FERKAVEKA</div>
          <div id="subtitle">2D Platformer Shooter</div>
        </div>
      </div>
    </div>

    <!-- UI Left -->
    <div id="ui">
      <div class="statPanel">
        <div class="statRow"><div>Ball</div><div id="score">0</div></div>
      </div>
      <div class="statPanel">
        <div style="font-weight:900">HP</div>
        <div class="hpBar"><div id="hpFill" class="hpFill"></div></div>
        <div style="font-size:12px;margin-top:8px;display:flex;justify-content:space-between">
          <div style="color:rgba(255,255,255,0.7)">Qurol: <span id="weaponLevel">1</span></div>
          <div style="color:rgba(255,255,255,0.7)">Masofa: <span id="distance">0</span>m</div>
        </div>
      </div>
    </div>

    <!-- Top-right -->
    <div id="topRight">
      <div id="togglePauseBtn" class="iconBtn" title="Pauza">‚è∏</div>
      <div id="toggleDayNight" class="iconBtn" title="Kun/Tun">‚òÄÔ∏è/üåô</div>
    </div>

    <!-- Canvas -->
    <canvas id="game"></canvas>

    <!-- Touch controls -->
    <div id="touchLeft">
      <div class="touchBtn" id="leftBtn">‚óÄ</div>
      <div class="touchBtn" id="rightBtn">‚ñ∂</div>
    </div>
    <div id="touchRight">
      <div class="touchBtn" id="jumpBtn">‚ñ≤</div>
      <div class="touchBtn" id="shootBtn">‚óè</div>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="overlay">
      <div class="loadBox">
        <div style="font-weight:900;color:var(--accent-2);font-size:20px">FERKAVEKA</div>
        <div class="pulse" style="margin-top:8px">Yuklanmoqda<span id="dots">...</span></div>
        <div style="margin-top:10px;color:rgba(255,255,255,0.65);font-size:13px">Iltimos kuting ‚Äî o‚Äòyin tez orada boshlanadi</div>
      </div>
    </div>

    <!-- Start Overlay (after loading) -->
    <div id="startOverlay" class="overlay hidden">
      <div class="panel">
        <h1>Ferkaveka ‚Äî Boshlash</h1>
        <p>Boshlash tugmasini bosing. Telefonda: chap ‚Äî harakat, o ªng ‚Äî sakrash va otish.</p>
        <button id="startBtn" class="btn">Boshlash</button>
      </div>
    </div>

    <!-- End Overlay -->
    <div id="endOverlay" class="overlay hidden">
      <div class="panel">
        <h1 id="endTitle">Siz yutdingiz!</h1>
        <p>Ballaringiz: <strong id="finalScore">0</strong></p>
        <button id="restartBtn" class="btn">Qayta boshlash</button>
      </div>
    </div>
  </div>

<script>
(() => {
  /* ---------------- setup canvas ---------------- */
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  function resizeCanvas(){
    let maxW = window.innerWidth * 0.94;
    let maxH = window.innerHeight * 0.78;
    let w = maxW, h = Math.floor(w * 9/16);
    if(h > maxH){ h = maxH; w = Math.floor(h * 16/9); }
    canvas.width = Math.max(480, Math.floor(w));
    canvas.height = Math.max(270, Math.floor(h));
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  /* ---------------- UI refs ---------------- */
  const loadingOverlay = document.getElementById('loadingOverlay');
  const startOverlay = document.getElementById('startOverlay');
  const endOverlay = document.getElementById('endOverlay');
  const startBtn = document.getElementById('startBtn');
  const restartBtn = document.getElementById('restartBtn');
  const scoreEl = document.getElementById('score');
  const weaponEl = document.getElementById('weaponLevel');
  const hpFill = document.getElementById('hpFill');
  const distanceEl = document.getElementById('distance');
  const finalScoreEl = document.getElementById('finalScore');
  const endTitle = document.getElementById('endTitle');
  const togglePauseBtn = document.getElementById('togglePauseBtn');
  const toggleDayNight = document.getElementById('toggleDayNight');

  /* touch btns */
  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const jumpBtn = document.getElementById('jumpBtn');
  const shootBtn = document.getElementById('shootBtn');

  /* ---------------- state ---------------- */
  const state = {
    running: false,
    paused: false,
    score: 0,
    weaponLevel: 1,
    distance: 0,
    day: true,
    difficulty: 1,
  };

  const world = {
    gravity: 1.0,
    platforms: [],
    walls: [],
    enemies: [],
    playerBullets: [],
    enemyBullets: [],
    particles: [],
    floatTexts: [],
  };

  const worldWidth = 4200;

  const player = {
    x: 120, y: 0, w: 48, h: 68,
    vx: 0, vy: 0, speed: 5.2, jumpPower: -18,
    onGround: false, facing: 1, hp: 100, maxHp: 100, legTimer: 0,
    canDoubleJump: true
  };

  let camX = 0, camLerp = 0.12;
  const input = { left:false, right:false, up:false, shoot:false, justJumped:false };

  /* ---------------- helpers ---------------- */
  function aabb(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }
  function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
  function rand(min,max){ return Math.random()*(max-min)+min; }

  /* ---------------- level builder ---------------- */
  function buildLevel(){
    const H = canvas.height;
    world.platforms = [
      {x:-1000,y: H-64, w: 8000, h: 64},
      {x:520,y:H-150,w:340,h:18},
      {x:980,y:H-200,w:300,h:18},
      {x:1440,y:H-250,w:260,h:18},
      {x:1900,y:H-310,w:340,h:18},
      {x:2360,y:H-360,w:300,h:18},
      {x:2800,y:H-420,w:260,h:18},
      {x:3200,y:H-480,w:520,h:18},
    ];
    world.walls = [
      {x:760,y:H-120,w:26,h:64},
      {x:1600,y:H-270,w:26,h:120},
      {x:2450,y:H-410,w:26,h:160}
    ];
    world.enemies = [];
    world.playerBullets = [];
    world.enemyBullets = [];
    world.particles = [];
    world.floatTexts = [];
  }

  /* ---------------- particles & float texts ---------------- */
  function spawnParticles(x,y,color,count=18){
    for(let i=0;i<count;i++){
      if(world.particles.length > 700) break;
      world.particles.push({ x,y, vx:(Math.random()-0.5)*6, vy:(Math.random()-1.5)*5, life:30+Math.random()*40, color, size:1+Math.random()*3 });
    }
  }
  function spawnFloatText(text, wx, wy, color='#fff'){
    const rect = canvas.getBoundingClientRect();
    const sx = rect.left + (wx - camX);
    const sy = rect.top + wy;
    const div = document.createElement('div');
    div.className = 'floatText';
    div.style.left = sx + 'px'; div.style.top = sy + 'px';
    div.style.color = color; div.style.fontSize = '16px';
    div.textContent = text; document.body.appendChild(div);
    world.floatTexts.push({el:div,x:sx,y:sy,vy:-0.6,life:80});
  }

  /* ---------------- enemies ---------------- */
  function spawnEnemy(x){
    const plat = world.platforms.find(p => x >= p.x-50 && x <= p.x + p.w + 50) || world.platforms[0];
    const e = {
      x, y: plat.y - 48, w: 44, h:48,
      vx: (Math.random()>0.5?1:-1)*(0.6+Math.random()*0.8),
      hp: 36 + Math.floor(Math.random()*34),
      type: 'grunt', timer:0, patrolLeft: x-120, patrolRight: x+120, speed: 0.6+Math.random()*0.9
    };
    world.enemies.push(e);
  }
  function spawnBoss(x){
    const plat = world.platforms.find(p => x >= p.x-120 && x <= p.x + p.w + 120) || world.platforms[0];
    const b = { x, y: plat.y - 180, w:140, h:160, vx:-0.45, hp:500, type:'boss', timer:0 };
    world.enemies.push(b); state.bossAlive = true;
  }

  /* ---------------- shooting ---------------- */
  let lastShot = 0;
  function playerShoot(){
    const now = performance.now();
    const rate = state.weaponLevel >= 3 ? 90 : state.weaponLevel === 2 ? 140 : 200;
    if(now - lastShot < rate) return; lastShot = now;
    const speed = state.weaponLevel >=2 ? 14 : 10;
    const dmg = state.weaponLevel >=2 ? 42 : 18;
    const bx = player.x + player.w/2 + player.facing*28;
    const by = player.y + 28;
    world.playerBullets.push({x:bx,y:by,w:10,h:6,vx:player.facing*speed,damage:dmg,life:420});
  }
  function enemyShoot(e){
    const sp = 7 + Math.random()*3;
    const dir = (player.x + player.w/2 > e.x) ? 1 : -1;
    world.enemyBullets.push({x:e.x + e.w/2, y:e.y + e.h/3, w:8,h:6, vx: dir*sp, damage:12, life:600});
  }

  /* ---------------- player update ---------------- */
  function updatePlayer(){
    if(input.left){ player.vx = -player.speed; player.facing = -1; }
    else if(input.right){ player.vx = player.speed; player.facing = 1; }
    else player.vx = 0;

    // jump: detect fresh press to avoid auto-multijump when holding
    if(input.up && player.onGround && input.justJumped){
      player.vy = player.jumpPower; player.onGround = false; player.canDoubleJump = true;
    } else if(input.up && !player.onGround && player.canDoubleJump && input.justJumped){
      player.vy = player.jumpPower * 0.82; player.canDoubleJump = false;
    }

    player.vy += world.gravity * 0.98;
    player.x += player.vx; player.y += player.vy;

    // walls
    for(const w of world.walls){
      if(aabb(player,w)){
        if(player.vx > 0) player.x = w.x - player.w - 0.1;
        else if(player.vx < 0) player.x = w.x + w.w + 0.1;
        player.vx = 0;
      }
    }

    // platforms
    player.onGround = false;
    for(const p of world.platforms){
      if(aabb(player,p)){
        if(player.vy > 0 && (player.y + player.h - player.vy) <= p.y + 6){
          player.y = p.y - player.h; player.vy = 0; player.onGround = true; player.canDoubleJump = true;
        } else if(player.vy < 0 && (player.y >= p.y + p.h - 4)){
          player.y = p.y + p.h + 0.1; player.vy = 0;
        }
      }
    }

    // bounds
    if(player.x < 0) player.x = 0;
    if(player.x + player.w > worldWidth) player.x = worldWidth - player.w;
    if(player.y > canvas.height + 260){
      // fell: penalize HP and respawn
      player.hp -= 28;
      spawnParticles(player.x + player.w/2, canvas.height - 32, '#f66', 28);
      if(player.hp <= 0){ endGame(false); }
      else { player.x = 120; player.y = 0; player.vx = 0; player.vy = 0; }
    }
  }

  /* ---------------- world update ---------------- */
  function updateWorld(){
    // player bullets vs enemies
    for(let i = world.playerBullets.length-1; i>=0; i--){
      const b = world.playerBullets[i]; b.x += b.vx; b.life -= 16;
      if(b.life <= 0 || b.x < 0 || b.x > worldWidth){ world.playerBullets.splice(i,1); continue; }
      for(let j = world.enemies.length-1; j>=0; j--){
        const e = world.enemies[j];
        if(aabb(b,e)){
          e.hp -= b.damage; spawnParticles(b.x,b.y,'#ffd',20);
          world.playerBullets.splice(i,1);
          if(e.hp <= 0){
            const isBoss = e.type === 'boss';
            state.score += isBoss ? 1200 : 120;
            scoreEl.textContent = state.score;
            spawnParticles(e.x+e.w/2,e.y+e.h/2,isBoss ? '#ffd400' : '#ff6a6a', 40);
            spawnFloatText('+' + (isBoss?1200:120), e.x + e.w/2, e.y);
            // chance weapon upgrade
            if(Math.random() < 0.18 && !isBoss){
              state.weaponLevel = Math.min(4, state.weaponLevel + 1);
              weaponEl.textContent = state.weaponLevel;
              spawnFloatText('Weapon +', e.x, e.y, '#9ff');
            }
            world.enemies.splice(j,1);
          }
          break;
        }
      }
    }

    // enemy bullets vs player
    for(let i = world.enemyBullets.length-1; i>=0; i--){
      const b = world.enemyBullets[i]; b.x += b.vx; b.life -= 16;
      if(b.life <= 0 || b.x < 0 || b.x > worldWidth){ world.enemyBullets.splice(i,1); continue; }
      if(aabb(b, player)){
        player.hp -= b.damage; spawnParticles(player.x+player.w/2, player.y+player.h/2, '#f00', 18);
        world.enemyBullets.splice(i,1); hpFill.style.width = Math.max(0,(player.hp/player.maxHp*100)) + '%';
        if(player.hp <= 0) endGame(false);
      }
    }

    // enemies AI & contact damage
    for(const e of world.enemies){
      e.timer = (e.timer || 0) + 1;
      if(e.type === 'grunt'){
        if(e.x < e.patrolLeft) e.vx = Math.abs(e.speed);
        if(e.x > e.patrolRight) e.vx = -Math.abs(e.speed);
        const dist = Math.abs((e.x + e.w/2) - (player.x + player.w/2));
        if(dist < 320){
          e.vx += ((player.x > e.x) ? 0.14 : -0.14);
          e.vx = clamp(e.vx, -2.2, 2.2);
          if(e.timer % Math.floor(80 + Math.random()*60) === 0) enemyShoot(e);
        }
      } else if(e.type === 'boss'){
        if(e.timer % Math.max(60, 80 - Math.floor(state.difficulty*2)) === 0) enemyShoot(e);
        e.vx += (player.x > e.x) ? 0.03 : -0.03;
        e.vx = clamp(e.vx, -1.6, 1.6);
      }
      e.x += e.vx;
      if(e.x < 30) e.x = 30;
      if(e.x + e.w > worldWidth - 30) e.x = worldWidth - e.w - 30;

      // contact damage if touching player (with cooldown)
      if(aabb(e, player)){
        if(!e._hitCooldown || performance.now() - e._hitCooldown > 650){
          player.hp -= e.type === 'boss' ? 20 : 12;
          spawnParticles(player.x+player.w/2, player.y+player.h/2, '#f33', 22);
          hpFill.style.width = Math.max(0,(player.hp/player.maxHp*100)) + '%';
          e._hitCooldown = performance.now();
          if(player.hp <= 0) endGame(false);
        }
      }
    }

    // particles
    for(let i = world.particles.length-1; i>=0; i--){
      const p = world.particles[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.25; p.life--;
      if(p.life <= 0) world.particles.splice(i,1);
    }

    // float texts (DOM)
    for(let i = world.floatTexts.length-1; i>=0; i--){
      const ft = world.floatTexts[i]; ft.x += 0; ft.y += ft.vy; ft.life--;
      ft.el.style.left = ft.x + 'px'; ft.el.style.top = ft.y + 'px'; ft.el.style.opacity = Math.max(0, ft.life/80);
      if(ft.life <= 0){ ft.el.remove(); world.floatTexts.splice(i,1); }
    }

    // cap particles
    if(world.particles.length > 800) world.particles.splice(0, world.particles.length - 800);
  }

  /* ---------------- camera & render ---------------- */
  function updateCamera(){
    const target = clamp(player.x - canvas.width/3, 0, worldWidth - canvas.width);
    camX += (target - camX) * camLerp;
    state.distance = Math.floor(player.x / 10);
    distanceEl.textContent = state.distance;
  }

  function render(){
    // background gradient
    const grd = ctx.createLinearGradient(0,0,0,canvas.height);
    if(state.day){ grd.addColorStop(0,'#0b2b43'); grd.addColorStop(1,'#07253a'); }
    else { grd.addColorStop(0,'#061226'); grd.addColorStop(1,'#02111a'); }
    ctx.fillStyle = grd; ctx.fillRect(0,0,canvas.width,canvas.height);

    // parallax sky element (sun/moon or stars)
    ctx.save(); ctx.translate(-camX*0.2,0);
    if(state.day){
      ctx.beginPath(); ctx.fillStyle='rgba(255,230,150,0.06)'; ctx.arc(canvas.width*0.82,80,80,0,Math.PI*2); ctx.fill();
    } else {
      for(let i=0;i<60;i++){
        const sx = (i*137) % (worldWidth) / worldWidth * canvas.width;
        const sy = (i*53) % (canvas.height*0.6);
        ctx.fillStyle = 'rgba(255,255,255,0.06)'; ctx.fillRect(sx,sy,2,2);
      }
    }
    ctx.restore();

    ctx.save(); ctx.translate(-camX,0);

    // platforms
    for(const p of world.platforms){
      ctx.fillStyle = '#1f4b63';
      roundRect(ctx, p.x, p.y, p.w, p.h, 8, true, false);
      ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 2; ctx.stroke();
    }
    // walls
    for(const w of world.walls){ ctx.fillStyle='#26424f'; ctx.fillRect(w.x,w.y,w.w,w.h); }

    // enemies
    for(const e of world.enemies){
      ctx.fillStyle = e.type === 'boss' ? '#ff9a1c' : '#ff4757';
      roundRect(ctx, e.x, e.y, e.w, e.h, 6, true, false);
      // HP bar
      ctx.fillStyle = '#000'; ctx.fillRect(e.x, e.y - 10, e.w, 6);
      ctx.fillStyle = '#33ff55'; const maxHp = e.type==='boss'?500:70; ctx.fillRect(e.x, e.y - 10, e.w * clamp(e.hp/maxHp,0,1), 6);
    }

    // bullets
    for(const b of world.playerBullets){ ctx.fillStyle = '#ffd86b'; ctx.fillRect(b.x,b.y,b.w,b.h); }
    for(const b of world.enemyBullets){ ctx.fillStyle = '#ff6b6b'; ctx.fillRect(b.x,b.y,b.w,b.h); }

    // particles
    for(const p of world.particles){ ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill(); }

    // player
    ctx.fillStyle = '#39a9db'; roundRect(ctx, player.x, player.y, player.w, player.h, 6, true, false);
    // legs
    ctx.strokeStyle = '#04212c'; ctx.lineWidth = 4;
    const legShift = Math.sin(player.legTimer/7) * 7;
    ctx.beginPath();
    ctx.moveTo(player.x + 8, player.y + player.h);
    ctx.lineTo(player.x + 24 + legShift * player.facing, player.y + player.h + 22);
    ctx.moveTo(player.x + player.w - 8, player.y + player.h);
    ctx.lineTo(player.x + 24 - legShift * player.facing, player.y + player.h + 22);
    ctx.stroke();

    ctx.restore();
  }

  function roundRect(ctx,x,y,w,h,r,fill,stroke){
    if(typeof r==='undefined') r=6;
    ctx.beginPath();
    ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
    if(fill) ctx.fill();
    if(stroke) ctx.stroke();
  }

  /* ---------------- main loop ---------------- */
  function update(){
    if(!state.running || state.paused) return;
    updatePlayer();
    if(input.shoot) playerShoot();
    updateWorld();
    updateCamera();
    // UI
    scoreEl.textContent = state.score;
    weaponEl.textContent = state.weaponLevel;
    hpFill.style.width = Math.max(0,(player.hp/player.maxHp*100)) + '%';
    player.legTimer++;
  }

  function loop(){
    update(); render();
    requestAnimationFrame(loop);
  }
  loop();

  /* ---------------- start/end/pause ---------------- */
  function startGame(){
    state.running = true; state.paused = false; state.score = 0; state.weaponLevel = 1; state.distance = 0; state.difficulty = 1;
    player.hp = player.maxHp; player.x = 120; player.y = 0; player.vx = 0; player.vy = 0; player.legTimer = 0;
    buildLevel();
    // spawn waves of enemies farther away to lengthen game
    for(let x=700;x<3200;x+=300) spawnEnemy(x + rand(-30,30));
    spawnBoss(3600);
    startOverlay.classList.add('hidden');
    endOverlay.classList.add('hidden');
  }
  function endGame(win){
    state.running = false;
    finalScoreEl.textContent = state.score;
    endTitle.textContent = win ? 'Tabriklar! Siz yutdingiz!' : 'Afsus, Siz yutqazdingiz!';
    endOverlay.classList.remove('hidden');
  }
  function togglePause(){
    if(!state.running) return;
    state.paused = !state.paused;
    togglePauseBtn.textContent = state.paused ? '‚ñ∂' : '‚è∏';
    if(state.paused){
      startOverlay.querySelector('h1').textContent = 'Pauza'; startOverlay.querySelector('p').textContent = 'Davom ettirish uchun boshing'; startOverlay.classList.remove('hidden');
    } else { startOverlay.classList.add('hidden'); startOverlay.querySelector('h1').textContent = 'Ferkaveka ‚Äî Boshlash'; startOverlay.querySelector('p').textContent = "Boshlash tugmasini bosing.";}
  }

  togglePauseBtn.addEventListener('click', togglePause);
  toggleDayNight.addEventListener('click', ()=>{ state.day = !state.day });

  startBtn.addEventListener('click', ()=>{ startGame(); });
  restartBtn.addEventListener('click', ()=>{ startGame(); endOverlay.classList.add('hidden'); });

  /* ---------------- input (keyboard + touch) ---------------- */
  window.addEventListener('keydown', e=>{
    if(e.key==='ArrowLeft' || e.key==='a') input.left = true;
    if(e.key==='ArrowRight' || e.key==='d') input.right = true;
    if(e.key==='ArrowUp' || e.key==='w' || e.key===' ') { if(!input.up) input.justJumped = true; input.up = true; }
    if(e.key==='k' || e.key==='x') input.shoot = true;
    if(e.key==='p') togglePause();
  });
  window.addEventListener('keyup', e=>{
    if(e.key==='ArrowLeft' || e.key==='a') input.left = false;
    if(e.key==='ArrowRight' || e.key==='d') input.right = false;
    if(e.key==='ArrowUp' || e.key==='w' || e.key===' ') input.up = false;
    if(e.key==='k' || e.key==='x') input.shoot = false;
    input.justJumped = false;
  });

  function bindTouch(btn, field){
    const start = e => { e.preventDefault(); input[field] = true; };
    const end = e => { e.preventDefault(); input[field] = false; };
    btn.addEventListener('touchstart', start, {passive:false}); btn.addEventListener('touchend', end);
    btn.addEventListener('mousedown', start); btn.addEventListener('mouseup', end); btn.addEventListener('mouseleave', end);
  }
  bindTouch(leftBtn,'left'); bindTouch(rightBtn,'right'); bindTouch(jumpBtn,'up'); bindTouch(shootBtn,'shoot');

  /* ---------------- periodic spawns to make game longer ---------------- */
  let lastWave = performance.now();
  setInterval(()=>{
    if(!state.running || state.paused) return;
    const now = performance.now();
    if(now - lastWave > 7000){ // every ~7s spawn some extra enemies
      lastWave = now; state.difficulty += 0.06;
      const baseX = clamp(player.x + canvas.width + 300, 700, worldWidth-200);
      // spawn 1-3 enemies ahead
      const count = Math.random() < 0.4 ? 2 : 1;
      for(let i=0;i<count;i++){
        spawnEnemy( baseX + i*80 + rand(-40,40) );
      }
      // occasionally spawn miniboss
      if(Math.random() < 0.12){
        spawnBoss( clamp(baseX + 300 + rand(-120,120), 1800, worldWidth-180) );
      }
    }
  }, 1000);

  /* enemy cleanup + win condition: if boss killed and no enemies remain and player far */
  setInterval(()=>{
    if(!state.running) return;
    // if player past most map end -> win
    if(player.x > worldWidth - 300 && world.enemies.length === 0){
      endGame(true);
    }
  }, 1500);

  /* ---------------- loading animation ---------------- */
  // animate dots, show loading 2.4s then start overlay
  (function loadingFlow(){
    const dotsEl = document.getElementById('dots');
    let d=0;
    const t = setInterval(()=>{ d=(d+1)%4; dotsEl.textContent = '.'.repeat(d); }, 420);
    setTimeout(()=>{
      clearInterval(t);
      loadingOverlay.classList.add('hidden');
      startOverlay.classList.remove('hidden');
    }, 2400);
  })();

  /* ---------------- handy: start paused until user clicks start ---------------- */
  // Render continues but game logic waits for startGame()

  /* ---------------- utility: expose minimal debug on window (optional) ---------------- */
  window._Ferk = { state, player, world };

})();
</script>
</body>
</html>
